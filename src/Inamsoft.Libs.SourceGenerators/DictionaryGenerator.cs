using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Inamsoft.Libs.SourceGenerators;

[Generator]
public sealed partial class DictionaryGenerator : IIncrementalGenerator
{
    // Constant definitions for GenerateDictionaryAttribute
    private const string GenerateDictionaryAttribNamespace = "Inamsoft.Libs.SourceGenerators.Attributes";
    
    private const string GenerateDictionaryAttribClassName = "GenerateDictionaryAttribute";
    private const string GenerateDictionaryAttribFullName = GenerateDictionaryAttribNamespace + "." + GenerateDictionaryAttribClassName;
    
    private const string DictionaryIgnoreAttribClassName = "DictionaryIgnoreAttribute";
    private const string DictionaryIgnoreAttribFullName = GenerateDictionaryAttribNamespace + "." + DictionaryIgnoreAttribClassName;
    
    // Constant definitions for AutoDictionaryAttribute
    private const string AutoDictionaryAttributeNamespace = "AutoDictionary";
    private const string AutoDictionaryAttributeGeneratedFileName = AutoDictionaryAttributeClassName + ".g.cs";
    
    private const string AutoDictionaryAttributeClassName = "AutoDictionaryAttribute";
    private const string AutoDictionaryAttributeFullName = AutoDictionaryAttributeNamespace + "." + AutoDictionaryAttributeClassName;
    
    private const string AutoDictionaryIgnoreAttributeClassName = "AutoDictionaryIgnoreAttribute";
    private const string AutoDictionaryIgnoreAttributeFullName = AutoDictionaryAttributeNamespace + "." + AutoDictionaryIgnoreAttributeClassName;
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {

        // 1. Inject attributes
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource(AutoDictionaryAttributeGeneratedFileName, $$"""
// <auto-generated by Muhammed Inam/>

namespace {{AutoDictionaryAttributeNamespace}}
{
    [System.AttributeUsage(
        System.AttributeTargets.Class |
        System.AttributeTargets.Struct)]
    public sealed class AutoDictionaryAttribute : System.Attribute { }
    
    [System.AttributeUsage(
        System.AttributeTargets.Property |
        System.AttributeTargets.Field)]
    public sealed class AutoDictionaryIgnoreAttribute : System.Attribute { }
}
""");
        });
        
        // 2. Find candidate type declarations with attributes
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) =>
                    node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) =>
                {
                    var typeDecl = (TypeDeclarationSyntax)ctx.Node;
                    var symbol = ctx.SemanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;
                    return symbol;
                })
            .Where(static symbol => symbol is not null);

        // 3. Filter to types marked with [AutoDictionary]
        var markedTypes = typeDeclarations
            .Where(static symbol =>
                symbol!.GetAttributes().Any(a =>
                    a.AttributeClass?.ToDisplayString() == AutoDictionaryAttributeFullName ||
                    a.AttributeClass?.ToDisplayString() == GenerateDictionaryAttribFullName));

        // 4. Generate the source per marked type
        context.RegisterSourceOutput(markedTypes, static (spc, typeSymbol) =>
        {
            var source = GenerateToDictionary(typeSymbol!);
            //var source = GenerateExtensionsFor(typeSymbol!);
            spc.AddSource($"{GetSafeTypeName(typeSymbol!)}_ToDictionary.g.cs", source);
        });
    }
    
    private static string GenerateToDictionary(INamedTypeSymbol typeSymbol)
    {
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : typeSymbol.ContainingNamespace.ToDisplayString();

        var typeName = typeSymbol.Name;
        var typeKindKeyword = typeSymbol.TypeKind switch
        {
            TypeKind.Class when typeSymbol is { IsRecord: false } => "class",
            TypeKind.Class when typeSymbol is { IsRecord: true } => "record",
            TypeKind.Struct => "struct",
            // There is no TypeKind.Record or TypeKind.RecordStruct in Roslyn's TypeKind enum.
            // Use IsRecord property to check for records.
            _ when typeSymbol is { IsRecord: true, TypeKind: TypeKind.Struct } => "record struct",
            _ when typeSymbol.IsRecord => "record",
            _ => "class"
        };

        // var props = typeSymbol.GetMembers()
        //     .OfType<IPropertySymbol>()
        //     .Where(p => p.GetMethod is not null && p.DeclaredAccessibility == Accessibility.Public)
        //     .ToImmutableArray();
        
        var members = GetAllIncludedMembers(typeSymbol!);
        //var members = GetAllMembers(typeSymbol!).ToImmutableArray();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Collections.ObjectModel;");
        sb.AppendLine();

        if (ns is not null)
        {
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();
        }

        sb.AppendFormat("// BaseType: {0}", typeSymbol.BaseType).AppendLine();
        sb.AppendFormat("// Kind: {0}", typeSymbol.TypeKind).AppendLine();
        sb.AppendFormat("// IsRecord: {0}", typeSymbol.IsRecord).AppendLine();

        sb.Append("public partial ").Append(typeKindKeyword).Append(' ')
            .Append(typeName);

        if (!typeSymbol.TypeParameters.IsEmpty)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", typeSymbol.TypeParameters.Select(tp => tp.Name)));
            sb.Append('>');
        }
        sb.AppendLine("{");
        
        // ToDictionary()
        sb.AppendLine("    public System.Collections.Generic.Dictionary<string, object?> ToDictionary()");
        sb.AppendLine("    {");
        sb.AppendLine("        var dict = new System.Collections.Generic.Dictionary<string, object?>();");

        foreach (var member in members)
        {
            //sb.AppendLine($"        dict[\"{member.Name}\"] = this.{member.Name};");
            GenerateMemberMapping(sb, typeSymbol, member);
        }

        sb.AppendLine();
        sb.AppendLine("        return dict;");
        sb.AppendLine("    }");
        
        // ToReadOnlyDictionary()
        sb.AppendLine("    public System.Collections.ObjectModel.ReadOnlyDictionary<string, object?> ToReadOnlyDictionary()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new System.Collections.ObjectModel.ReadOnlyDictionary<string, object?>(ToDictionary());");
        sb.AppendLine("    }");
        
        // End
        sb.AppendLine("}");
        
        

        return sb.ToString();
    }
    
    private static string GenerateExtensionsFor(INamedTypeSymbol typeSymbol)
    {
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : typeSymbol.ContainingNamespace.ToDisplayString();

        var fullTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var safeTypeName = GetSafeTypeName(typeSymbol);

        var members = GetIncludedMembers(typeSymbol);

        var sb = new StringBuilder();

        if (ns is not null)
        {
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();
        }

        // Static extension class
        sb.AppendLine("file static class __AutoDictionaryExtensions_" + safeTypeName);
        sb.AppendLine("{");

        // ToDictionary extension
        sb.AppendLine($"    public static System.Collections.Generic.IReadOnlyDictionary<string, object?> ToDictionary(this {fullTypeName} instance)");
        sb.AppendLine("    {");
        sb.AppendLine("        var dict = new System.Collections.Generic.Dictionary<string, object?>();");
        sb.AppendLine();
        sb.AppendLine("        if (instance is null)");
        sb.AppendLine("        {");
        sb.AppendLine("            return dict;"); // empty
        sb.AppendLine("        }");
        sb.AppendLine();

        foreach (var member in members)
        {
            GenerateMemberMapping(sb, typeSymbol, member);
        }

        sb.AppendLine("        return dict;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
    
    private static ImmutableArray<ISymbol> GetIncludedMembers(INamedTypeSymbol typeSymbol)
    {
        var props = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p =>
                p.DeclaredAccessibility == Accessibility.Public &&
                p.GetMethod is not null &&
                !HasIgnoreAttribute(p, DictionaryIgnoreAttribFullName) &&
                !p.IsStatic);

        var fields = typeSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f =>
                f.DeclaredAccessibility == Accessibility.Public &&
                !f.IsStatic &&
                !f.IsConst &&
                !HasIgnoreAttribute(f, DictionaryIgnoreAttribFullName));

        return [
            ..props.Cast<ISymbol>()
                .Concat(fields)
        ];
    }
    
    private static ImmutableArray<ISymbol> GetAllIncludedMembers(INamedTypeSymbol typeSymbol)
    {
        List<ISymbol> members = new List<ISymbol>(20);

        var currentSymbol = typeSymbol;
        do
        {
            var props = currentSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p =>
                    p.DeclaredAccessibility == Accessibility.Public &&
                    p.GetMethod is not null &&
                    !HasIgnoreAttribute(p, DictionaryIgnoreAttribFullName) &&
                    !p.IsStatic);

            var fields = currentSymbol.GetMembers()
                .OfType<IFieldSymbol>()
                .Where(f =>
                    f.DeclaredAccessibility == Accessibility.Public &&
                    f is { IsStatic: false, IsConst: false } &&
                    !HasIgnoreAttribute(f, DictionaryIgnoreAttribFullName));
            
            members.AddRange(props);
            members.AddRange(fields);
            
            currentSymbol = currentSymbol.BaseType;

        } while (currentSymbol?.BaseType is not null);
        

        return [..members];
    }
    
    private static IEnumerable<ISymbol> GetAllMembers(INamedTypeSymbol type)
    {
        for (var current = type; current is not null; current = current.BaseType)
        {
            foreach (var member in current.GetMembers())
                yield return member;
        }
    }

    private static bool HasIgnoreAttribute(ISymbol symbol, string fullAttributeName)
    {
        return symbol.GetAttributes()
            .Any(a => a.AttributeClass?.ToDisplayString() == fullAttributeName);
    }

    private static void GenerateMemberMapping(
        StringBuilder sb,
        INamedTypeSymbol containingType,
        ISymbol member)
    {
        var memberName = member.Name;
        var memberAccess = "this." + memberName;
        ITypeSymbol memberType;

        switch (member)
        {
            case IPropertySymbol prop:
                memberType = prop.Type;
                break;
            case IFieldSymbol field:
                memberType = field.Type;
                break;
            default:
                return;
        }

        var isNullable = memberType.NullableAnnotation == NullableAnnotation.Annotated;

        // Check if a member type itself is decorated with [AutoDictionary]
        var isAutoDictionaryType = IsAutoDictionaryType(memberType);

        if (isAutoDictionaryType)
        {
            // Nested flattening
            sb.AppendLine();
            sb.AppendLine($"        if ({memberAccess} is not null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            foreach (var kvp in {memberAccess}.ToDictionary())");
            sb.AppendLine("            {");
            sb.AppendLine($"                dict[$\"{memberName}.{{kvp.Key}}\"] = kvp.Value;");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
        else
        {
            // Simple store
            if (isNullable || memberType.IsReferenceType)
            {
                sb.AppendLine($"        dict[\"{memberName}\"] = {memberAccess};");
                //sb.AppendLine();
            }
            else
            {
                // Value type, non-nullable
                sb.AppendLine($"        dict[\"{memberName}\"] = {memberAccess};");
                //sb.AppendLine();
            }
        }
    }

    private static bool IsAutoDictionaryType(ITypeSymbol typeSymbol)
    {
        // Unwrap Nullable<T> if present
        if (typeSymbol is INamedTypeSymbol named &&
            named.IsGenericType &&
            named.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
        {
            typeSymbol = named.TypeArguments[0];
        }

        if (typeSymbol is not INamedTypeSymbol nts)
            return false;

        return nts.GetAttributes()
            .Any(a => a.AttributeClass?.ToDisplayString() == AutoDictionaryAttributeFullName || a.AttributeClass?.ToDisplayString() == GenerateDictionaryAttribFullName);
    }

    private static void GenerateDictionaryForType(SourceProductionContext context, INamedTypeSymbol typeSymbol)
    {
        //var attributeData = typeSymbol.GetAttributes().First(a =>
        //    a.AttributeClass?.ToDisplayString() == "Inamsoft.Libs.SourceGenerators.Attributes.GenerateDictionaryAttribute");

        var attributeData = typeSymbol.GetAttributes().First();


        var namingPolicyEnumValue = 0;
        if (attributeData.ConstructorArguments.Length == 1 &&
            attributeData.ConstructorArguments[0].Value is int intVal)
        {
            namingPolicyEnumValue = intVal;
        }

        var properties = GetRelevantProperties(typeSymbol).ToImmutableArray();

        if (properties.Length == 0)
        {
            // Diagnostic: type annotated but has no public properties
            var diag = Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "ADICT001",
                    title: "No public properties",
                    messageFormat: "Type '{0}' is marked with [GenerateDictionary] but has no public readable properties.",
                    category: "AutoDict",
                    DiagnosticSeverity.Warning,
                    isEnabledByDefault: true),
                typeSymbol.Locations.FirstOrDefault(),
                typeSymbol.Name);

            context.ReportDiagnostic(diag);
            return;
        }

        var source = GenerateSourceForType(typeSymbol, properties, namingPolicyEnumValue);
        context.AddSource($"{typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace('.', '_')}_Dictionary.g.cs", source);
    }

    private static IEnumerable<PropertyInfoForDict> GetRelevantProperties(INamedTypeSymbol typeSymbol)
    {
        var hasGenerateDictAttribute = typeSymbol.GetAttributes()
            .Any(a => a.AttributeClass?.ToDisplayString() == "AutoDict.GenerateDictionaryAttribute");

        foreach (var member in typeSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (member.IsStatic) continue;
            if (member.IsIndexer) continue;
            if (member.DeclaredAccessibility != Accessibility.Public) continue;
            if (member.GetMethod is null) continue;

            var ignored = member.GetAttributes()
                .Any(a => a.AttributeClass?.ToDisplayString() == "AutoDict.DictionaryIgnoreAttribute");
            if (ignored) continue;

            var memberType = member.Type;
            var nestedHasAttribute = memberType.GetAttributes()
                .Any(a => a.AttributeClass?.ToDisplayString() == "AutoDict.GenerateDictionaryAttribute");

            // We treat nested flattenable if the nested type also has [GenerateDictionary].
            var isFlattenable = nestedHasAttribute;

            yield return new PropertyInfoForDict(
                Name: member.Name,
                Type: memberType,
                IsFlattenableNested: isFlattenable,
                AccessExpression: $"this.{member.Name}"
            );
        }
    }
    private static string GetSafeTypeName(INamedTypeSymbol typeSymbol)
    {
        // Turn things like Namespace.Outer+Inner<T> into a file-safe name
        var name = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var builder = new StringBuilder(name.Length);

        foreach (var ch in name)
        {
            builder.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }

        return builder.ToString();
    }
}

public sealed partial class DictionaryGenerator
{
    private static string GenerateSourceForType(
        INamedTypeSymbol typeSymbol,
        ImmutableArray<PropertyInfoForDict> properties,
        int namingPolicyEnumValue)
    {
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : typeSymbol.ContainingNamespace.ToDisplayString();

        var typeKindKeyword = typeSymbol.TypeKind switch
        {
            TypeKind.Class => "class",
            TypeKind.Struct => "struct",
            // There is no TypeKind.Record or TypeKind.RecordStruct in Roslyn's TypeKind enum.
            // Use IsRecord property to check for records.
            _ when typeSymbol.IsRecord && typeSymbol.TypeKind == TypeKind.Struct => "record struct",
            _ when typeSymbol.IsRecord => "record",
            _ => "class"
        };

        var sb = new StringBuilder();

        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Collections.ObjectModel;");
        sb.AppendLine();

        if (ns is not null)
        {
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();
        }

        sb.Append("public partial ").Append(typeKindKeyword).Append(' ')
            .Append(typeSymbol.Name);

        if (!typeSymbol.TypeParameters.IsEmpty)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", typeSymbol.TypeParameters.Select(tp => tp.Name)));
            sb.Append('>');
        }

        sb.AppendLine();
        sb.AppendLine("{");

        // ToDictionary()
        sb.AppendLine("    public System.Collections.Generic.Dictionary<string, object?> ToDictionary()");
        sb.AppendLine("    {");
        sb.AppendLine("        var dict = new System.Collections.Generic.Dictionary<string, object?>();");

        EmitPropertyAssignments(sb, properties, namingPolicyEnumValue, "dict");

        sb.AppendLine("        return dict;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ToDictionary<TValue>()
        sb.AppendLine("    public System.Collections.Generic.Dictionary<string, TValue?> ToDictionary<TValue>()");
        sb.AppendLine("    {");
        sb.AppendLine("        var dict = new System.Collections.Generic.Dictionary<string, TValue?>();");

        EmitPropertyAssignmentsGeneric(sb, properties, namingPolicyEnumValue, "dict");

        sb.AppendLine("        return dict;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ToReadOnlyDictionary()
        sb.AppendLine("    public System.Collections.ObjectModel.ReadOnlyDictionary<string, object?> ToReadOnlyDictionary()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new System.Collections.ObjectModel.ReadOnlyDictionary<string, object?>(ToDictionary());");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitPropertyAssignments(
        StringBuilder sb,
        ImmutableArray<PropertyInfoForDict> properties,
        int namingPolicyEnumValue,
        string dictVarName)
    {
        foreach (var p in properties)
        {
            if (p.IsFlattenableNested)
            {
                // Flatten by calling nested object's ToDictionary()
                sb.Append("        if (")
                    .Append(p.AccessExpression)
                    .AppendLine(" is not null)")
                  .Append("        {")
                    .AppendLine()
                  .Append("            foreach (var kvp in ")
                    .Append(p.AccessExpression)
                    .AppendLine(".ToDictionary())")
                  .AppendLine("            {")
                  .Append("                ")
                    .Append(dictVarName)
                    .AppendLine("[kvp.Key] = kvp.Value;")
                  .AppendLine("            }")
                  .AppendLine("        }");
            }
            else
            {
                var key = NamingHelper.ApplyNamingPolicy(p.Name, namingPolicyEnumValue);
                sb.Append("        ")
                  .Append(dictVarName)
                  .Append("[\"")
                  .Append(key)
                  .Append("\"] = ")
                  .Append(p.AccessExpression)
                  .AppendLine(";");
            }
        }
    }

    private static void EmitPropertyAssignmentsGeneric(
        StringBuilder sb,
        ImmutableArray<PropertyInfoForDict> properties,
        int namingPolicyEnumValue,
        string dictVarName)
    {
        foreach (var p in properties)
        {
            if (p.IsFlattenableNested)
            {
                sb.Append("        if (")
                    .Append(p.AccessExpression)
                    .AppendLine(" is not null)")
                  .Append("        {")
                    .AppendLine()
                  .Append("            foreach (var kvp in ")
                    .Append(p.AccessExpression)
                    .AppendLine(".ToDictionary<TValue>())")
                  .AppendLine("            {")
                  .Append("                ")
                    .Append(dictVarName)
                    .AppendLine("[kvp.Key] = kvp.Value;")
                  .AppendLine("            }")
                  .AppendLine("        }");
            }
            else
            {
                var key = NamingHelper.ApplyNamingPolicy(p.Name, namingPolicyEnumValue);
                sb.Append("        ")
                  .Append(dictVarName)
                  .Append("[\"")
                  .Append(key)
                  .Append("\"] = (TValue?)(")
                  .Append(p.AccessExpression)
                  .AppendLine(");");
            }
        }
    }
}
